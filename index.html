<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>9:16 Image Converter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- JSZip library for creating zip files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Cropper.js for manual cropping -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .dotted-border {
            border-style: dashed;
        }
        .ai-content {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        /* Simple transition for collapsible panels */
        .collapsible-panel {
            transition: opacity 0.3s ease-in-out, max-height 0.4s ease-in-out, padding 0.3s, margin 0.3s;
            max-height: 500px;
            overflow: hidden;
        }
        .collapsible-panel.hidden {
            opacity: 0;
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            margin-top: 0;
            margin-bottom: 0;
        }
        .color-swatch {
            width: 2rem;
            height: 2rem;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            transition: transform 0.2s;
        }
        .color-swatch:hover {
            transform: scale(1.1);
        }
        /* Cropper.js needs this to display correctly */
        #crop-image-container > img {
          display: block;
          max-width: 100%;
        }
        .control-btn.active {
            background-color: #06b6d4; /* Tailwind cyan-500 */
            color: #111827; /* Tailwind gray-900 */
        }
        .preset-btn.active {
            background-color: #a855f7; /* Tailwind purple-500 */
             color: #ffffff;
        }
    </style>
</head>
<body class="bg-slate-900 text-white flex items-center justify-center min-h-screen p-2 sm:p-4">

    <div class="w-full max-w-2xl mx-auto">
        <div class="bg-slate-800 rounded-2xl p-4 sm:p-8 shadow-2xl">
            <div class="text-center">
                <h1 class="text-2xl sm:text-3xl font-bold text-cyan-400">9:16 Image Converter</h1>
                <p class="text-slate-400 mt-2">A powerful offline-first image editor.</p>
            </div>

            <!-- Image Upload Section -->
            <div id="upload-container" class="mt-8">
                <label for="image-upload" class="flex flex-col items-center justify-center w-full h-48 sm:h-64 border-2 border-slate-600 dotted-border rounded-xl cursor-pointer hover:bg-slate-700 transition-colors">
                    <div class="flex flex-col items-center justify-center pt-5 pb-6">
                        <svg class="w-10 h-10 mb-3 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
                        <p class="mb-2 text-sm text-slate-400"><span class="font-semibold">Click to upload</span> or drag and drop</p>
                        <p class="text-xs text-slate-500">Upload up to 50 images (PNG, JPG, WEBP)</p>
                    </div>
                    <input id="image-upload" type="file" class="hidden" accept="image/png, image/jpeg, image/webp" multiple />
                </label>
            </div>

            <!-- Results Section -->
            <div id="result-container" class="mt-6 hidden">
                 <!-- Mode Selector -->
                <div class="flex items-center justify-center space-x-4 sm:space-x-6 mb-4">
                    <label class="flex items-center cursor-pointer">
                        <input type="radio" name="mode" value="fit" class="peer sr-only" checked>
                        <span class="px-4 py-2 text-sm sm:text-base font-medium text-slate-300 rounded-md peer-checked:bg-cyan-500 peer-checked:text-slate-900 transition-colors">Fit & Customize</span>
                    </label>
                    <label class="flex items-center cursor-pointer">
                        <input type="radio" name="mode" value="fill" class="peer sr-only">
                        <span class="px-4 py-2 text-sm sm:text-base font-medium text-slate-300 rounded-md peer-checked:bg-cyan-500 peer-checked:text-slate-900 transition-colors">Fill and Crop</span>
                    </label>
                </div>

                <!-- AI Smart Crop & Manual Crop Button -->
                <div id="smart-crop-container" class="my-4 hidden">
                    <div class="flex flex-col sm:flex-row gap-4">
                        <button id="manual-crop-btn" class="w-full bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 px-4 rounded-lg transition-colors text-sm">Manual Crop</button>
                        <button id="smart-crop-btn" class="ai-feature w-full bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-4 rounded-lg transition-colors text-sm">✨ Suggest Smart Crop</button>
                    </div>
                    <div id="smart-crop-preview" class="hidden mt-4 p-2 bg-slate-700/50 rounded-lg">
                        <p class="text-center text-xs text-slate-400 mb-2">AI Suggested Crop:</p>
                        <canvas id="smart-crop-canvas" class="w-full rounded-md"></canvas>
                        <div class="flex gap-2 mt-2">
                            <button id="accept-crop-btn" class="w-full text-xs bg-green-500 hover:bg-green-600 py-1 rounded-md">Accept</button>
                            <button id="cancel-crop-btn" class="w-full text-xs bg-slate-600 hover:bg-slate-700 py-1 rounded-md">Cancel</button>
                        </div>
                    </div>
                </div>

                <!-- Background Customization Options -->
                <div id="fit-mode-options" class="bg-slate-700/50 rounded-lg p-4 my-4 collapsible-panel">
                    <div class="text-center mb-4 text-sm font-medium text-slate-300">Background Options</div>
                    <div class="flex justify-center gap-4 mb-4">
                        <label><input type="radio" name="bg-type" value="blur" class="mr-2" checked>Blur</label>
                        <label><input type="radio" name="bg-type" value="solid" class="mr-2">Solid Color</label>
                    </div>
                    <div id="blur-controls">
                        <label for="blur-slider" class="block text-xs text-slate-400 mb-1">Blur Amount</label>
                        <input type="range" id="blur-slider" min="0" max="50" value="25" class="w-full">
                    </div>
                    <div id="color-controls" class="hidden">
                        <label for="bg-color-picker" class="block text-xs text-slate-400 mb-1">Background Color</label>
                        <input type="color" id="bg-color-picker" value="#1e293b" class="w-full h-10 p-1 bg-slate-800 rounded-md cursor-pointer">
                        <button id="suggest-colors-btn" class="ai-feature w-full mt-3 bg-rose-500 hover:bg-rose-600 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm">✨ Suggest Colors</button>
                        <div id="color-swatches-container" class="mt-3 flex justify-center gap-3 flex-wrap"></div>
                    </div>
                </div>

                <!-- Borders & Framing Panel -->
                <div id="framing-panel" class="bg-slate-700/50 rounded-lg p-4 my-4 collapsible-panel">
                    <div class="text-center mb-3 text-sm font-medium text-slate-300">Framing & Sizing</div>
                    <div class="mt-3">
                        <label for="zoom-slider" class="block text-xs text-slate-400 mb-1">Image Zoom</label>
                        <input type="range" id="zoom-slider" min="100" max="250" value="100" class="w-full">
                    </div>
                    <div class="grid grid-cols-2 gap-4 mt-3">
                        <div>
                           <label for="border-thickness-slider" class="block text-xs text-slate-400 mb-1">Border Thickness</label>
                           <input type="range" id="border-thickness-slider" min="0" max="50" value="0" class="w-full">
                        </div>
                        <div>
                            <label for="border-color-picker" class="block text-xs text-slate-400 mb-1">Border Color</label>
                            <input type="color" id="border-color-picker" value="#FFFFFF" class="w-full h-10 p-1 bg-slate-800 rounded-md cursor-pointer">
                        </div>
                    </div>
                     <div class="mt-3">
                        <label for="corner-radius-slider" class="block text-xs text-slate-400 mb-1">Corner Radius</label>
                        <input type="range" id="corner-radius-slider" min="0" max="200" value="0" class="w-full">
                    </div>
                </div>

                <!-- Preset Filter Panel -->
                <div id="preset-filter-panel" class="bg-slate-700/50 rounded-lg p-4 my-4 collapsible-panel">
                    <div class="text-center mb-3 text-sm font-medium text-slate-300">Preset Filters</div>
                    <div class="grid grid-cols-2 sm:grid-cols-4 gap-2">
                         <button class="preset-btn text-xs px-3 py-2 bg-slate-600 rounded-md" data-preset="vintage">Vintage</button>
                         <button class="preset-btn text-xs px-3 py-2 bg-slate-600 rounded-md" data-preset="bw">B & W</button>
                         <button class="preset-btn text-xs px-3 py-2 bg-slate-600 rounded-md" data-preset="cool">Cool</button>
                         <button class="preset-btn text-xs px-3 py-2 bg-slate-600 rounded-md" data-preset="warm">Warm</button>
                    </div>
                </div>

                <!-- Image Filters -->
                <div id="filter-options" class="bg-slate-700/50 rounded-lg p-4 my-4 collapsible-panel">
                    <div class="text-center mb-4 text-sm font-medium text-slate-300">Filter & Adjust</div>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="brightness-slider" class="block text-xs text-slate-400 mb-1">Brightness</label>
                            <input type="range" id="brightness-slider" min="0" max="200" value="100" class="w-full">
                        </div>
                        <div>
                            <label for="contrast-slider" class="block text-xs text-slate-400 mb-1">Contrast</label>
                            <input type="range" id="contrast-slider" min="0" max="200" value="100" class="w-full">
                        </div>
                        <div>
                            <label for="saturate-slider" class="block text-xs text-slate-400 mb-1">Saturation</label>
                            <input type="range" id="saturate-slider" min="0" max="200" value="100" class="w-full">
                        </div>
                         <div>
                            <label for="sepia-slider" class="block text-xs text-slate-400 mb-1">Sepia</label>
                            <input type="range" id="sepia-slider" min="0" max="100" value="0" class="w-full">
                        </div>
                    </div>
                     <div class="mt-3 col-span-2">
                        <label for="vignette-slider" class="block text-xs text-slate-400 mb-1">Vignette</label>
                        <input type="range" id="vignette-slider" min="0" max="100" value="0" class="w-full">
                    </div>
                    <div class="mt-3 col-span-2">
                        <label for="grain-slider" class="block text-xs text-slate-400 mb-1">Film Grain</label>
                        <input type="range" id="grain-slider" min="0" max="50" value="0" class="w-full">
                    </div>
                    <div class="flex justify-center gap-2 mt-4 flex-wrap">
                        <button class="filter-btn control-btn text-xs px-3 py-1 bg-slate-600 rounded-md" data-filter="grayscale">Grayscale</button>
                        <button class="filter-btn control-btn text-xs px-3 py-1 bg-slate-600 rounded-md" data-filter="invert">Invert</button>
                        <button id="reset-filters-btn" class="text-xs px-3 py-1 bg-rose-500 rounded-md">Reset</button>
                    </div>
                </div>


                <p id="loading-message" class="text-center text-slate-400 mb-4 hidden">Processing your images...</p>
                <!-- Container for multiple canvases -->
                <div id="canvas-container" class="grid grid-cols-1 md:grid-cols-2 gap-6"></div>
                
                <div class="mt-8 flex flex-col sm:flex-row gap-4">
                     <button id="download-all-btn" class="w-full bg-cyan-500 hover:bg-cyan-600 text-slate-900 font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-cyan-400 focus:ring-opacity-75">
                        Download All (.zip)
                    </button>
                    <button id="new-upload-btn" class="w-full bg-slate-600 hover:bg-slate-700 text-white font-bold py-3 px-4 rounded-lg transition-colors">
                        Upload Others
                    </button>
                </div>
            </div>
        </div>
        <footer class="text-center mt-6">
            <p class="text-sm text-slate-500">AI features powered by Gemini</p>
        </footer>
    </div>
    
    <!-- Manual Crop Modal -->
    <div id="crop-modal" class="fixed inset-0 bg-slate-900 bg-opacity-90 flex items-center justify-center z-50 hidden">
      <div class="bg-slate-800 p-4 rounded-lg shadow-2xl max-w-lg w-full">
        <p class="text-center text-white mb-4 font-semibold">Select Your Crop</p>
        <div id="crop-image-container">
          <img id="crop-image-target" src="">
        </div>
        <div class="flex gap-4 mt-4">
          <button id="confirm-crop-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Confirm</button>
          <button id="close-modal-btn" class="w-full bg-slate-600 hover:bg-slate-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Cancel</button>
        </div>
      </div>
    </div>


    <script>
        // --- Global Configuration ---
        const apiKey = ""; // Works automatically in this environment

        // --- Element Selectors ---
        const uploadContainer = document.getElementById('upload-container');
        const resultContainer = document.getElementById('result-container');
        const imageUpload = document.getElementById('image-upload');
        const downloadAllBtn = document.getElementById('download-all-btn');
        const newUploadBtn = document.getElementById('new-upload-btn');
        const canvasContainer = document.getElementById('canvas-container');
        const loadingMessage = document.getElementById('loading-message');
        const fitModeOptions = document.getElementById('fit-mode-options');
        const suggestColorsBtn = document.getElementById('suggest-colors-btn');
        const colorSwatchesContainer = document.getElementById('color-swatches-container');
        const smartCropContainer = document.getElementById('smart-crop-container');
        const smartCropBtn = document.getElementById('smart-crop-btn');
        const manualCropBtn = document.getElementById('manual-crop-btn');
        const cropModal = document.getElementById('crop-modal');
        const cropImageTarget = document.getElementById('crop-image-target');
        const confirmCropBtn = document.getElementById('confirm-crop-btn');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const framingPanel = document.getElementById('framing-panel');
        
        let currentImages = [];
        let cropCoords = null;
        let cropper = null;
        let grainPattern = null;

        // --- Drag and Drop ---
        const dropArea = uploadContainer.querySelector('label');
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(e => { dropArea.addEventListener(e, preventDefaults, false); document.body.addEventListener(e, preventDefaults, false); });
        ['dragenter', 'dragover'].forEach(e => dropArea.addEventListener(e, () => dropArea.classList.add('bg-slate-700'), false));
        ['dragleave', 'drop'].forEach(e => dropArea.addEventListener(e, () => dropArea.classList.remove('bg-slate-700'), false));
        dropArea.addEventListener('drop', e => handleFiles(e.dataTransfer.files), false);
        function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }

        imageUpload.addEventListener('change', (e) => handleFiles(e.target.files));

        function handleFiles(files) {
            if (!files || files.length === 0) return;
            cropCoords = null; 
            const filesToProcess = Array.from(files).slice(0, 50);
            const imagePromises = filesToProcess.map(file => new Promise((resolve) => {
                if (!file.type.startsWith('image/')) { resolve(null); return; }
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => resolve({ img, type: file.type });
                    img.onerror = () => resolve(null);
                    img.src = event.target.result;
                };
                reader.onerror = () => resolve(null);
                reader.readAsDataURL(file);
            }));
            uploadContainer.classList.add('hidden');
            resultContainer.classList.remove('hidden');
            loadingMessage.classList.remove('hidden');
            canvasContainer.innerHTML = '';
            document.querySelector('input[name="mode"][value="fit"]').checked = true;
            document.getElementById('smart-crop-container').classList.add('hidden');
            Promise.all(imagePromises).then(results => {
                currentImages = results.filter(r => r !== null);
                renderAllImages('fit');
                loadingMessage.classList.add('hidden');
            }).catch(error => {
                console.error("Error loading images:", error);
                loadingMessage.innerText = "Error loading images.";
            });
        }
        
        function renderAllImages(mode) {
            canvasContainer.innerHTML = ''; 
            currentImages.forEach((imgData, index) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'bg-slate-700/50 p-3 rounded-xl flex flex-col gap-3';
                const canvas = document.createElement('canvas');
                canvas.className = 'w-full rounded-lg shadow-md touch-none'; 
                canvas.id = `canvas-${index}`;
                
                const singleDownloadBtn = document.createElement('button');
                singleDownloadBtn.innerHTML = `Download Image`;
                singleDownloadBtn.className = 'w-full bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-4 rounded-lg transition-colors';
                singleDownloadBtn.onclick = () => downloadSingleImage(canvas, index);
                
                wrapper.appendChild(canvas);
                wrapper.appendChild(singleDownloadBtn);
                canvasContainer.appendChild(wrapper);
                processImage(imgData.img, mode, canvas);
            });
        }

        // PERFORMANCE OPTIMIZATION: Debounce function
        const debounce = (func, wait) => {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };
        
        const debouncedRedraw = debounce(redrawAllImages, 200); // Wait 200ms after user stops moving slider

        function redrawAllImages() {
            const mode = document.querySelector('input[name="mode"]:checked').value;
            canvasContainer.querySelectorAll('canvas').forEach((canvas, index) => {
                processImage(currentImages[index].img, mode, canvas);
            });
        }

        function getFilters() {
            const brightness = document.getElementById('brightness-slider').value;
            const contrast = document.getElementById('contrast-slider').value;
            const saturate = document.getElementById('saturate-slider').value;
            const sepia = document.getElementById('sepia-slider').value;
            const grayscale = document.body.dataset.grayscale === '1' ? 1 : 0;
            const invert = document.body.dataset.invert === '1' ? 1 : 0;
            return `brightness(${brightness}%) contrast(${contrast}%) saturate(${saturate}%) sepia(${sepia}%) grayscale(${grayscale}) invert(${invert})`;
        }

        function processImage(img, mode, canvas) {
            if (!img || !canvas) return;
            const ctx = canvas.getContext('2d');
            const aspectRatio = 9 / 16;
            const outputHeight = 1920; 
            const outputWidth = outputHeight * aspectRatio;
            canvas.width = outputWidth;
            canvas.height = outputHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            const imageAspectRatio = img.width / img.height;

            if (mode === 'fit') {
                const bgType = document.querySelector('input[name="bg-type"]:checked').value;
                if (bgType === 'blur') {
                    const blurAmount = document.getElementById('blur-slider').value;
                    ctx.filter = `blur(${blurAmount}px) brightness(0.7)`;
                    ctx.drawImage(img, 0, 0, outputWidth, outputHeight);
                } else {
                    const bgColor = document.getElementById('bg-color-picker').value;
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(0, 0, outputWidth, outputHeight);
                }
                
                ctx.save();
                
                let baseWidth, baseHeight;
                if (imageAspectRatio > aspectRatio) { baseWidth = outputWidth; baseHeight = baseWidth / imageAspectRatio; } 
                else { baseHeight = outputHeight; baseWidth = baseHeight * imageAspectRatio; }
                
                const zoom = document.getElementById('zoom-slider').value / 100;
                const drawWidth = baseWidth * zoom;
                const drawHeight = baseHeight * zoom;
                const x = (outputWidth - drawWidth) / 2;
                const y = (outputHeight - drawHeight) / 2;

                const cornerRadius = document.getElementById('corner-radius-slider').value;
                if (cornerRadius > 0) {
                    ctx.beginPath();
                    ctx.moveTo(x + cornerRadius, y);
                    ctx.lineTo(x + drawWidth - cornerRadius, y);
                    ctx.quadraticCurveTo(x + drawWidth, y, x + drawWidth, y + cornerRadius);
                    ctx.lineTo(x + drawWidth, y + drawHeight - cornerRadius);
                    ctx.quadraticCurveTo(x + drawWidth, y + drawHeight, x + drawWidth - cornerRadius, y + drawHeight);
                    ctx.lineTo(x + cornerRadius, y + drawHeight);
                    ctx.quadraticCurveTo(x, y + drawHeight, x, y + drawHeight - cornerRadius);
                    ctx.lineTo(x, y + cornerRadius);
                    ctx.quadraticCurveTo(x, y, x + cornerRadius, y);
                    ctx.closePath();
                    ctx.clip();
                }

                ctx.filter = getFilters(); 
                ctx.drawImage(img, x, y, drawWidth, drawHeight);
                ctx.restore();
                ctx.filter = 'none';

                const borderThickness = document.getElementById('border-thickness-slider').value;
                if(borderThickness > 0) {
                    ctx.strokeStyle = document.getElementById('border-color-picker').value;
                    ctx.lineWidth = borderThickness * 2;
                    ctx.strokeRect(x, y, drawWidth, drawHeight);
                }

                const grainStrength = document.getElementById('grain-slider').value;
                if (grainStrength > 0 && grainPattern) {
                    ctx.save();
                    ctx.globalAlpha = grainStrength / 100;
                    ctx.fillStyle = grainPattern;
                    ctx.fillRect(0, 0, outputWidth, outputHeight);
                    ctx.restore();
                }

                const vignetteStrength = document.getElementById('vignette-slider').value;
                if (vignetteStrength > 0) {
                    const outerRadius = Math.sqrt(Math.pow(outputWidth / 2, 2) + Math.pow(outputHeight / 2, 2));
                    const gradient = ctx.createRadialGradient(outputWidth / 2, outputHeight / 2, outerRadius * (1 - vignetteStrength / 100), outputWidth / 2, outputHeight / 2, outerRadius);
                    gradient.addColorStop(0, `rgba(0,0,0,0)`);
                    gradient.addColorStop(1, `rgba(0,0,0,0.8)`);
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, outputWidth, outputHeight);
                }

            } else if (mode === 'fill') {
                let sx, sy, sWidth, sHeight;
                if(cropCoords) { ({sx, sy, sWidth, sHeight} = cropCoords); } 
                else {
                    sx = 0; sy = 0; sWidth = img.width; sHeight = img.height;
                    if (imageAspectRatio > aspectRatio) { sWidth = sHeight * aspectRatio; sx = (img.width - sWidth) / 2; } 
                    else { sHeight = sWidth / aspectRatio; sy = (img.height - sHeight) / 2; }
                }
                ctx.filter = getFilters(); 
                ctx.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, outputWidth, outputHeight);
                ctx.filter = 'none';

                const grainStrength = document.getElementById('grain-slider').value;
                if (grainStrength > 0 && grainPattern) {
                    ctx.save();
                    ctx.globalAlpha = grainStrength / 100;
                    ctx.fillStyle = grainPattern;
                    ctx.fillRect(0, 0, outputWidth, outputHeight);
                    ctx.restore();
                }
                 // Vignette for fill mode
                const vignetteStrength = document.getElementById('vignette-slider').value;
                if (vignetteStrength > 0) {
                    const outerRadius = Math.sqrt(Math.pow(outputWidth / 2, 2) + Math.pow(outputHeight / 2, 2));
                    const gradient = ctx.createRadialGradient(outputWidth / 2, outputHeight / 2, outerRadius * (1 - vignetteStrength / 100), outputWidth / 2, outputHeight / 2, outerRadius);
                    gradient.addColorStop(0, `rgba(0,0,0,0)`);
                    gradient.addColorStop(1, `rgba(0,0,0,0.8)`);
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, outputWidth, outputHeight);
                }
            }
        }

        function downloadSingleImage(canvas, index) {
            const link = document.createElement('a');
            const mode = document.querySelector('input[name="mode"]:checked').value;
            link.download = `converted-9x16-${mode}-${index + 1}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // --- Event Listeners for Controls ---
        document.querySelectorAll('input[name="mode"]').forEach(radio => radio.addEventListener('change', (event) => {
            const isFitMode = event.target.value === 'fit';
            fitModeOptions.classList.toggle('hidden', !isFitMode);
            framingPanel.classList.toggle('hidden', !isFitMode);
            smartCropContainer.classList.toggle('hidden', isFitMode);
            document.getElementById('smart-crop-preview').classList.add('hidden');
            cropCoords = null;
            redrawAllImages();
        }));
        
        // Use 'input' for live preview with debounce for sliders
        document.querySelectorAll('input[type="range"]').forEach(el => {
            el.addEventListener('input', debouncedRedraw);
        });
        
        // Use 'change' for color pickers (fires when picker is closed)
        document.querySelectorAll('input[type="color"]').forEach(el => {
            el.addEventListener('change', redrawAllImages);
        });

        // Use 'click' for buttons
        document.querySelectorAll('input[name="bg-type"], .filter-btn, .preset-btn').forEach(button => {
             button.addEventListener('click', (e) => {
                if(e.currentTarget.classList.contains('filter-btn')){
                    const filter = e.target.dataset.filter;
                    document.body.dataset[filter] = document.body.dataset[filter] === '1' ? '0' : '1';
                    e.target.classList.toggle('active');
                } else if(e.currentTarget.classList.contains('preset-btn')){
                     applyPreset(e.target.dataset.preset);
                }
                redrawAllImages();
            });
        });
        
        function applyPreset(presetName) {
            const presets = {
                vintage: { bright: 110, contrast: 105, sat: 90, sepia: 30, vignette: 40, grain: 15, gray: 0 },
                bw: { bright: 105, contrast: 120, sat: 0, sepia: 0, vignette: 25, grain: 20, gray: 1 },
                cool: { bright: 105, contrast: 110, sat: 110, sepia: 0, vignette: 10, grain: 0, gray: 0 },
                warm: { bright: 100, contrast: 100, sat: 115, sepia: 15, vignette: 15, grain: 5, gray: 0 },
            };
            const preset = presets[presetName];
            if (!preset) return;
            
            document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.preset-btn[data-preset="${presetName}"]`).classList.add('active');

            document.getElementById('brightness-slider').value = preset.bright;
            document.getElementById('contrast-slider').value = preset.contrast;
            document.getElementById('saturate-slider').value = preset.sat;
            document.getElementById('sepia-slider').value = preset.sepia;
            document.getElementById('vignette-slider').value = preset.vignette;
            document.getElementById('grain-slider').value = preset.grain;
            document.body.dataset.grayscale = preset.gray;
            document.body.dataset.invert = '0';
            
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            if(preset.gray) document.querySelector('[data-filter="grayscale"]').classList.add('active');
        }
        
        document.getElementById('reset-filters-btn').addEventListener('click', () => {
            document.getElementById('brightness-slider').value = 100;
            document.getElementById('contrast-slider').value = 100;
            document.getElementById('saturate-slider').value = 100;
            document.getElementById('sepia-slider').value = 0;
            document.getElementById('vignette-slider').value = 0;
            document.getElementById('grain-slider').value = 0;
            document.body.dataset.grayscale = '0';
            document.body.dataset.invert = '0';
            document.querySelectorAll('.filter-btn, .preset-btn').forEach(btn => btn.classList.remove('active'));
            cropCoords = null; 
            redrawAllImages();
        });

        // Manual Cropper Logic
        manualCropBtn.addEventListener('click', () => {
            if (currentImages.length === 0) return;
            cropImageTarget.src = currentImages[0].img.src;
            cropModal.classList.remove('hidden');
            if (cropper) { cropper.destroy(); }
            cropper = new Cropper(cropImageTarget, {
                aspectRatio: 9 / 16, viewMode: 1, background: false, autoCropArea: 0.8,
                movable: true, zoomable: true, rotatable: false, scalable: false,
            });
        });
        closeModalBtn.addEventListener('click', () => {
            cropModal.classList.add('hidden');
            if (cropper) { cropper.destroy(); cropper = null; }
        });
        confirmCropBtn.addEventListener('click', () => {
            if (!cropper) return;
            const data = cropper.getData(true);
            cropCoords = { sx: data.x, sy: data.y, sWidth: data.width, sHeight: data.height, };
            closeModalBtn.click();
            redrawAllImages();
        });
        
        // Film Grain Pattern Generation
        function createGrainPattern() {
            const grainCanvas = document.createElement('canvas');
            const grainCtx = grainCanvas.getContext('2d');
            const size = 100;
            grainCanvas.width = size;
            grainCanvas.height = size;
            const imageData = grainCtx.createImageData(size, size);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const val = Math.random() * 255;
                data[i] = val; data[i + 1] = val; data[i + 2] = val; data[i + 3] = 255;
            }
            grainCtx.putImageData(imageData, 0, 0);
            grainPattern = document.createElement('canvas').getContext('2d').createPattern(grainCanvas, 'repeat');
        }

        // --- Smart AI Feature Status Updater ---
        function updateAiFeatureStatus() {
            const isOnline = navigator.onLine;
            document.querySelectorAll('.ai-feature').forEach(button => {
                button.disabled = !isOnline;
                button.classList.toggle('opacity-50', !isOnline);
                button.classList.toggle('cursor-not-allowed', !isOnline);
                button.title = isOnline ? '' : 'This feature requires an internet connection.';
            });
        }
        window.addEventListener('online', updateAiFeatureStatus);
        window.addEventListener('offline', updateAiFeatureStatus);
        document.addEventListener('DOMContentLoaded', () => {
            updateAiFeatureStatus();
            createGrainPattern();
        });
        
        // --- Gemini API Functions ---
        async function makeGeminiApiCall(payload) {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) throw new Error(`API Error: ${response.status} ${response.statusText}`);
            const result = await response.json();
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!text) throw new Error("No content found in API response.");
            return text;
        }
        
        async function getSuggestedColors() {
            if (currentImages.length === 0) return;
            colorSwatchesContainer.innerHTML = `<span class="text-xs text-slate-400">✨ Analyzing...</span>`;
            try {
                const firstImage = currentImages[0];
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = 200;
                tempCanvas.height = firstImage.img.height * (200 / firstImage.img.width);
                tempCanvas.getContext('2d').drawImage(firstImage.img, 0, 0, tempCanvas.width, tempCanvas.height);
                const dataUrl = tempCanvas.toDataURL(firstImage.type, 0.9);
                const base64Data = dataUrl.split(',')[1];
                const payload = { contents: [{ parts: [ { text: "Analyze this image. Suggest 5 complementary hex color codes for a background. Provide the response as a valid JSON array of strings. Example: [\"#1A2B3C\", \"#D4E5F6\"]" }, { inlineData: { mimeType: 'image/jpeg', data: base64Data } } ] }], };
                const responseText = await makeGeminiApiCall(payload);
                const colorMatch = responseText.match(/\[.*\]/s);
                if (!colorMatch) throw new Error("Invalid format from API.");
                const colors = JSON.parse(colorMatch[0]);
                colorSwatchesContainer.innerHTML = ''; 
                colors.forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.backgroundColor = color;
                    swatch.title = color;
                    swatch.onclick = () => { document.getElementById('bg-color-picker').value = color; redrawAllImages(); };
                    colorSwatchesContainer.appendChild(swatch);
                });
            } catch (error) {
                console.error("Gemini color suggestion failed:", error);
                colorSwatchesContainer.innerHTML = `<span class="text-xs text-rose-400">Could not get suggestions.</span>`;
            }
        }

        async function suggestSmartCrop() {
            if (currentImages.length === 0) return;
            smartCropBtn.innerHTML = '✨ Analyzing...';
            smartCropBtn.disabled = true;
            try {
                const firstImage = currentImages[0];
                const dataUrl = firstImage.img.src;
                const base64Data = dataUrl.split(',')[1];
                const prompt = "Analyze this image and identify the bounding box of the most important subject or focal point. Respond with ONLY a valid JSON object containing keys for 'x', 'y', 'width', and 'height'. The values should be normalized from 0.0 to 1.0, representing the position and size relative to the image dimensions. Example: {\"x\": 0.25, \"y\": 0.1, \"width\": 0.5, \"height\": 0.8}";
                const payload = { contents: [{ parts: [ { text: prompt }, { inlineData: { mimeType: firstImage.type, data: base64Data } } ] }] };
                const responseText = await makeGeminiApiCall(payload);
                const jsonMatch = responseText.match(/{.*}/s);
                if (!jsonMatch) throw new Error("Invalid format from API.");
                const subjectBox = JSON.parse(jsonMatch[0]);
                
                const img = firstImage.img;
                const aspectRatio = 9 / 16;
                let sWidth = img.height * aspectRatio; let sHeight = img.height;
                if (sWidth > img.width) { sWidth = img.width; sHeight = img.width / aspectRatio; }

                const subjectX = subjectBox.x * img.width; const subjectY = subjectBox.y * img.height;
                const subjectWidth = subjectBox.width * img.width; const subjectHeight = subjectBox.height * img.height;
                const subjectCenterX = subjectX + subjectWidth / 2; const subjectCenterY = subjectY + subjectHeight / 2;

                let sx = subjectCenterX - sWidth / 2; let sy = subjectCenterY - sHeight / 2;

                if (sx < 0) sx = 0; if (sy < 0) sy = 0;
                if (sx + sWidth > img.width) sx = img.width - sWidth;
                if (sy + sHeight > img.height) sy = img.height - sHeight;

                cropCoords = { sx, sy, sWidth, sHeight };
                showSmartCropPreview(cropCoords);

            } catch (error) {
                console.error("Gemini Smart Crop failed:", error);
                alert("Sorry, I couldn't suggest a crop. Please try again.");
            } finally {
                smartCropBtn.innerHTML = '✨ Suggest Smart Crop';
                smartCropBtn.disabled = false;
            }
        }

        function showSmartCropPreview(coords) {
            const previewContainer = document.getElementById('smart-crop-preview');
            const canvas = document.getElementById('smart-crop-canvas');
            const ctx = canvas.getContext('2d');
            const img = currentImages[0].img;
            
            canvas.width = img.width; canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, coords.sx, coords.sy, coords.sWidth, coords.sHeight, coords.sx, coords.sy, coords.sWidth, coords.sHeight);
            ctx.strokeStyle = '#06b6d4';
            ctx.lineWidth = 8;
            ctx.strokeRect(coords.sx, coords.sy, coords.sWidth, coords.sHeight);
            previewContainer.classList.remove('hidden');
        }

        document.getElementById('accept-crop-btn').addEventListener('click', () => {
            document.getElementById('smart-crop-preview').classList.add('hidden');
            redrawAllImages();
        });

        document.getElementById('cancel-crop-btn').addEventListener('click', () => {
            document.getElementById('smart-crop-preview').classList.add('hidden');
            cropCoords = null;
            redrawAllImages();
        });


        smartCropBtn.addEventListener('click', suggestSmartCrop);
        suggestColorsBtn.addEventListener('click', getSuggestedColors);
        downloadAllBtn.addEventListener('click', () => {
            if (typeof JSZip === 'undefined') { console.error("JSZip library not loaded!"); return; }
            const zip = new JSZip();
            const canvases = canvasContainer.querySelectorAll('canvas');
            const mode = document.querySelector('input[name="mode"]:checked').value;
            canvases.forEach((canvas, index) => {
                const dataUrl = canvas.toDataURL('image/png');
                zip.file(`converted-9x16-${mode}-${index + 1}.png`, dataUrl.split(',')[1], { base64: true });
            });
            zip.generateAsync({type:"blob"}).then(function(content) {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = "converted-images.zip";
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });
        });
        newUploadBtn.addEventListener('click', () => {
            uploadContainer.classList.remove('hidden');
            resultContainer.classList.add('hidden');
            imageUpload.value = ''; 
            currentImages = [];
            canvasContainer.innerHTML = '';
            colorSwatchesContainer.innerHTML = '';
            cropCoords = null;
        });
    </script>
</body>
</html>

